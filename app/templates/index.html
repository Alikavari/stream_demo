<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>AssemblyAI Realtime ‚Äî Partial + Final</title>
    <style>
      body {
        font-family: system-ui, sans-serif;
        margin: 0;
        background: #f6f7f9;
        color: #222;
      }
      .wrap {
        max-width: 900px;
        margin: 40px auto;
        background: #fff;
        padding: 24px;
        border-radius: 12px;
        box-shadow: 0 4px 18px rgba(0, 0, 0, 0.08);
      }
      button {
        padding: 10px 16px;
        border: 0;
        border-radius: 8px;
        background: #42b883;
        color: #fff;
        cursor: pointer;
      }
      button:hover {
        background: #2e8b63;
      }
      .box-wrap {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
        margin-top: 20px;
      }
      .box {
        background: #f1f5f9;
        border-radius: 8px;
        padding: 12px;
        min-height: 160px;
        white-space: pre-wrap;
      }
      .log {
        background: #0f172a;
        color: #e2e8f0;
        font-family: monospace;
        padding: 10px;
        border-radius: 8px;
        height: 160px;
        overflow: auto;
        margin-top: 16px;
      }
      input {
        margin: 5px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <h2>üé§ AssemblyAI Realtime ‚Äî Partial + Final</h2>

      <!-- Control Button -->
      <button id="btn">Start Recording</button>
      <span id="status">Idle</span>

      <!-- Parameter Panel -->
      <h3>‚öôÔ∏è Turn Detection Tuning</h3>

      <label
        >Confidence (0‚Äì1):
        <input
          id="conf"
          type="number"
          step="0.05"
          min="0"
          max="1"
          value="0.4"
        /> </label
      ><br />

      <label
        >Min Silence (ms):
        <input id="minsil" type="number" value="560" /> </label
      ><br />

      <label
        >Max Silence (ms):
        <input id="maxsil" type="number" value="1500" /> </label
      ><br />

      <button id="apply">Apply Live</button>
      <hr />

      <!-- Output Boxes -->
      <div class="box-wrap">
        <div class="box">
          <h3>üü¢ Live Partial</h3>
          <div id="partialBox"></div>
        </div>
        <div class="box">
          <h3>üü£ Final Transcript (Turn by turn)</h3>
          <div id="finalBox"></div>
        </div>
      </div>

      <div class="log" id="log"></div>
    </div>

    <script>
      const TOKEN_URL = "http://localhost:8000/get_token";
      const SAMPLE_RATE = 16000;

      const $btn = document.getElementById("btn");
      const $status = document.getElementById("status");
      const $log = document.getElementById("log");
      const $partial = document.getElementById("partialBox");
      const $final = document.getElementById("finalBox");
      const log = (...a) => {
        $log.textContent += a.join(" ") + "\n";
        $log.scrollTop = $log.scrollHeight;
      };

      let ws = null,
        audioContext = null,
        mediaStream = null,
        workletNode = null,
        isRec = false;
      let turnCounter = 1; // ‚úÖ turn counter

      // ---- Worklet Blob ----
      const makeWorkletBlob = () => {
        const code = `
    function downsampleTo16k(f32, rate){
      if(rate===16000) return f32;
      const ratio=rate/16000, n=Math.floor(f32.length/ratio);
      const out=new Float32Array(n);
      for(let i=0;i<n;i++){
        const s=Math.floor(i*ratio),e=Math.floor((i+1)*ratio);
        let sum=0;for(let j=s;j<e&&j<f32.length;j++) sum+=f32[j];
        out[i]=sum/Math.max(1,e-s);
      }
      return out;
    }
    class PCM16Downsampler extends AudioWorkletProcessor{
      constructor(){super();this.buf=new Float32Array(0);this.sp=1600;}
      append(x){const tmp=new Float32Array(this.buf.length+x.length);tmp.set(this.buf);tmp.set(x,this.buf.length);this.buf=tmp;}
      take(n){const r=this.buf.slice(0,n);this.buf=this.buf.slice(n);return r;}
      f32toI16(a){const i16=new Int16Array(a.length);
        for(let i=0;i<a.length;i++){const s=Math.min(1,Math.max(-1,a[i]));i16[i]=s<0?s*0x8000:s*0x7fff;}return i16;}
      process(inputs){
        const input=inputs[0]; if(!input||!input[0]) return true;
        const d=downsampleTo16k(input[0],sampleRate); this.append(d);
        while(this.buf.length>=this.sp){
          const chunk=this.take(this.sp);const out=this.f32toI16(chunk);
          this.port.postMessage(out.buffer,[out.buffer]);
        }
        return true;
      }
    }
    registerProcessor("pcm16-downsampler",PCM16Downsampler);
  `;
        return URL.createObjectURL(
          new Blob([code], { type: "application/javascript" })
        );
      };

      // ---- Start Stream ----
      async function start() {
        try {
          $btn.disabled = true;
          $status.textContent = "Mic‚Ä¶";
          mediaStream = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });

          const conf = document.getElementById("conf").value;
          const minsil = document.getElementById("minsil").value;
          const maxsil = document.getElementById("maxsil").value;

          const t = await fetch(TOKEN_URL).then((r) => r.json());
          if (!t.token) throw new Error("No token");

          turnCounter = 1; // ‚úÖ reset turn counter at start
          $final.textContent = ""; // ‚úÖ clear output

          ws = new WebSocket(
            `wss://streaming.assemblyai.com/v3/ws` +
              `?sample_rate=${SAMPLE_RATE}` +
              `&encoding=pcm_s16le` +
              `&end_of_turn_confidence_threshold=${conf}` +
              `&min_end_of_turn_silence_when_confident=${minsil}` +
              `&max_turn_silence=${maxsil}` +
              `&token=${encodeURIComponent(t.token)}`
          );

          ws.onopen = async () => {
            log("‚úÖ WS open");
            $status.textContent = "Streaming‚Ä¶";

            audioContext = new AudioContext({ sampleRate: SAMPLE_RATE });
            await audioContext.resume();

            const blobURL = makeWorkletBlob();
            await audioContext.audioWorklet.addModule(blobURL);
            URL.revokeObjectURL(blobURL);

            const src = audioContext.createMediaStreamSource(mediaStream);
            workletNode = new AudioWorkletNode(
              audioContext,
              "pcm16-downsampler"
            );

            workletNode.port.onmessage = (e) => {
              if (ws?.readyState === WebSocket.OPEN) {
                ws.send(new Uint8Array(e.data));
              }
            };

            const silent = audioContext.createGain();
            silent.gain.value = 0;
            src
              .connect(workletNode)
              .connect(silent)
              .connect(audioContext.destination);

            let partial = "",
              full = "";

            ws.onmessage = (evt) => {
              try {
                const msg = JSON.parse(evt.data);
                if (msg.type === "Begin") {
                  log("Session", msg.id);
                  return;
                }

                if (msg.type === "Turn" && msg.transcript) {
                  if (!msg.end_of_turn) {
                    partial = msg.transcript.trim();
                  } else {
                    const text = msg.transcript.trim();
                    if (text) {
                      full += `${turnCounter}) ${text}\n`;
                      turnCounter++;
                    }
                    partial = "";
                  }
                }

                $partial.textContent = partial || "‚Ä¶";
                $final.textContent = full;
              } catch {}
            };

            ws.onclose = (e) => {
              log("üî¥ closed", e.code);
              stop();
            };
            ws.onerror = (e) => console.error(e);

            isRec = true;
            $btn.textContent = "Stop Recording";
            $btn.disabled = false;
          };
        } catch (e) {
          console.error(e);
          $status.textContent = "Error";
          log("ERR", e);
        }
      }

      // ---- Stop ----
      function stop() {
        isRec = false;
        $btn.textContent = "Start Recording";
        try {
          workletNode?.disconnect();
        } catch {}
        try {
          audioContext?.close();
        } catch {}
        try {
          mediaStream?.getTracks().forEach((t) => t.stop());
        } catch {}
        try {
          ws?.close();
        } catch {}
        $status.textContent = "Stopped";
      }

      $btn.onclick = () => (isRec ? stop() : start());
      window.onbeforeunload = stop;

      // ---- Live Update ----
      document.getElementById("apply").onclick = () => {
        if (!ws || ws.readyState !== WebSocket.OPEN)
          return alert("Not streaming!");

        const msg = {
          type: "UpdateConfiguration",
          end_of_turn_confidence_threshold: parseFloat(
            document.getElementById("conf").value
          ),
          min_end_of_turn_silence_when_confident: parseInt(
            document.getElementById("minsil").value
          ),
          max_turn_silence: parseInt(document.getElementById("maxsil").value),
        };

        ws.send(JSON.stringify(msg));
        log("‚öôÔ∏è Live Update ->", JSON.stringify(msg));
      };
    </script>
  </body>
</html>
